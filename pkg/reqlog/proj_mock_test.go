// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package reqlog_test

import (
	"context"
	"github.com/dstotijn/hetty/pkg/proj"
	"sync"
)

// Ensure, that ProjServiceMock does implement proj.Service.
// If this is not the case, regenerate this file with moq.
var _ proj.Service = &ProjServiceMock{}

// ProjServiceMock is a mock implementation of proj.Service.
//
// 	func TestSomethingThatUsesService(t *testing.T) {
//
// 		// make and configure a mocked proj.Service
// 		mockedService := &ProjServiceMock{
// 			ActiveProjectFunc: func() (proj.Project, error) {
// 				panic("mock out the ActiveProject method")
// 			},
// 			CloseFunc: func() error {
// 				panic("mock out the Close method")
// 			},
// 			DeleteFunc: func(name string) error {
// 				panic("mock out the Delete method")
// 			},
// 			OnProjectCloseFunc: func(fn proj.OnProjectCloseFn)  {
// 				panic("mock out the OnProjectClose method")
// 			},
// 			OnProjectOpenFunc: func(fn proj.OnProjectOpenFn)  {
// 				panic("mock out the OnProjectOpen method")
// 			},
// 			OpenFunc: func(ctx context.Context, name string) (proj.Project, error) {
// 				panic("mock out the Open method")
// 			},
// 			ProjectsFunc: func() ([]proj.Project, error) {
// 				panic("mock out the Projects method")
// 			},
// 		}
//
// 		// use mockedService in code that requires proj.Service
// 		// and then make assertions.
//
// 	}
type ProjServiceMock struct {
	// ActiveProjectFunc mocks the ActiveProject method.
	ActiveProjectFunc func() (proj.Project, error)

	// CloseFunc mocks the Close method.
	CloseFunc func() error

	// DeleteFunc mocks the Delete method.
	DeleteFunc func(name string) error

	// OnProjectCloseFunc mocks the OnProjectClose method.
	OnProjectCloseFunc func(fn proj.OnProjectCloseFn)

	// OnProjectOpenFunc mocks the OnProjectOpen method.
	OnProjectOpenFunc func(fn proj.OnProjectOpenFn)

	// OpenFunc mocks the Open method.
	OpenFunc func(ctx context.Context, name string) (proj.Project, error)

	// ProjectsFunc mocks the Projects method.
	ProjectsFunc func() ([]proj.Project, error)

	// calls tracks calls to the methods.
	calls struct {
		// ActiveProject holds details about calls to the ActiveProject method.
		ActiveProject []struct {
		}
		// Close holds details about calls to the Close method.
		Close []struct {
		}
		// Delete holds details about calls to the Delete method.
		Delete []struct {
			// Name is the name argument value.
			Name string
		}
		// OnProjectClose holds details about calls to the OnProjectClose method.
		OnProjectClose []struct {
			// Fn is the fn argument value.
			Fn proj.OnProjectCloseFn
		}
		// OnProjectOpen holds details about calls to the OnProjectOpen method.
		OnProjectOpen []struct {
			// Fn is the fn argument value.
			Fn proj.OnProjectOpenFn
		}
		// Open holds details about calls to the Open method.
		Open []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Name is the name argument value.
			Name string
		}
		// Projects holds details about calls to the Projects method.
		Projects []struct {
		}
	}
	lockActiveProject  sync.RWMutex
	lockClose          sync.RWMutex
	lockDelete         sync.RWMutex
	lockOnProjectClose sync.RWMutex
	lockOnProjectOpen  sync.RWMutex
	lockOpen           sync.RWMutex
	lockProjects       sync.RWMutex
}

// ActiveProject calls ActiveProjectFunc.
func (mock *ProjServiceMock) ActiveProject() (proj.Project, error) {
	if mock.ActiveProjectFunc == nil {
		panic("ProjServiceMock.ActiveProjectFunc: method is nil but Service.ActiveProject was just called")
	}
	callInfo := struct {
	}{}
	mock.lockActiveProject.Lock()
	mock.calls.ActiveProject = append(mock.calls.ActiveProject, callInfo)
	mock.lockActiveProject.Unlock()
	return mock.ActiveProjectFunc()
}

// ActiveProjectCalls gets all the calls that were made to ActiveProject.
// Check the length with:
//     len(mockedService.ActiveProjectCalls())
func (mock *ProjServiceMock) ActiveProjectCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockActiveProject.RLock()
	calls = mock.calls.ActiveProject
	mock.lockActiveProject.RUnlock()
	return calls
}

// Close calls CloseFunc.
func (mock *ProjServiceMock) Close() error {
	if mock.CloseFunc == nil {
		panic("ProjServiceMock.CloseFunc: method is nil but Service.Close was just called")
	}
	callInfo := struct {
	}{}
	mock.lockClose.Lock()
	mock.calls.Close = append(mock.calls.Close, callInfo)
	mock.lockClose.Unlock()
	return mock.CloseFunc()
}

// CloseCalls gets all the calls that were made to Close.
// Check the length with:
//     len(mockedService.CloseCalls())
func (mock *ProjServiceMock) CloseCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockClose.RLock()
	calls = mock.calls.Close
	mock.lockClose.RUnlock()
	return calls
}

// Delete calls DeleteFunc.
func (mock *ProjServiceMock) Delete(name string) error {
	if mock.DeleteFunc == nil {
		panic("ProjServiceMock.DeleteFunc: method is nil but Service.Delete was just called")
	}
	callInfo := struct {
		Name string
	}{
		Name: name,
	}
	mock.lockDelete.Lock()
	mock.calls.Delete = append(mock.calls.Delete, callInfo)
	mock.lockDelete.Unlock()
	return mock.DeleteFunc(name)
}

// DeleteCalls gets all the calls that were made to Delete.
// Check the length with:
//     len(mockedService.DeleteCalls())
func (mock *ProjServiceMock) DeleteCalls() []struct {
	Name string
} {
	var calls []struct {
		Name string
	}
	mock.lockDelete.RLock()
	calls = mock.calls.Delete
	mock.lockDelete.RUnlock()
	return calls
}

// OnProjectClose calls OnProjectCloseFunc.
func (mock *ProjServiceMock) OnProjectClose(fn proj.OnProjectCloseFn) {
	if mock.OnProjectCloseFunc == nil {
		panic("ProjServiceMock.OnProjectCloseFunc: method is nil but Service.OnProjectClose was just called")
	}
	callInfo := struct {
		Fn proj.OnProjectCloseFn
	}{
		Fn: fn,
	}
	mock.lockOnProjectClose.Lock()
	mock.calls.OnProjectClose = append(mock.calls.OnProjectClose, callInfo)
	mock.lockOnProjectClose.Unlock()
	mock.OnProjectCloseFunc(fn)
}

// OnProjectCloseCalls gets all the calls that were made to OnProjectClose.
// Check the length with:
//     len(mockedService.OnProjectCloseCalls())
func (mock *ProjServiceMock) OnProjectCloseCalls() []struct {
	Fn proj.OnProjectCloseFn
} {
	var calls []struct {
		Fn proj.OnProjectCloseFn
	}
	mock.lockOnProjectClose.RLock()
	calls = mock.calls.OnProjectClose
	mock.lockOnProjectClose.RUnlock()
	return calls
}

// OnProjectOpen calls OnProjectOpenFunc.
func (mock *ProjServiceMock) OnProjectOpen(fn proj.OnProjectOpenFn) {
	if mock.OnProjectOpenFunc == nil {
		panic("ProjServiceMock.OnProjectOpenFunc: method is nil but Service.OnProjectOpen was just called")
	}
	callInfo := struct {
		Fn proj.OnProjectOpenFn
	}{
		Fn: fn,
	}
	mock.lockOnProjectOpen.Lock()
	mock.calls.OnProjectOpen = append(mock.calls.OnProjectOpen, callInfo)
	mock.lockOnProjectOpen.Unlock()
	mock.OnProjectOpenFunc(fn)
}

// OnProjectOpenCalls gets all the calls that were made to OnProjectOpen.
// Check the length with:
//     len(mockedService.OnProjectOpenCalls())
func (mock *ProjServiceMock) OnProjectOpenCalls() []struct {
	Fn proj.OnProjectOpenFn
} {
	var calls []struct {
		Fn proj.OnProjectOpenFn
	}
	mock.lockOnProjectOpen.RLock()
	calls = mock.calls.OnProjectOpen
	mock.lockOnProjectOpen.RUnlock()
	return calls
}

// Open calls OpenFunc.
func (mock *ProjServiceMock) Open(ctx context.Context, name string) (proj.Project, error) {
	if mock.OpenFunc == nil {
		panic("ProjServiceMock.OpenFunc: method is nil but Service.Open was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		Name string
	}{
		Ctx:  ctx,
		Name: name,
	}
	mock.lockOpen.Lock()
	mock.calls.Open = append(mock.calls.Open, callInfo)
	mock.lockOpen.Unlock()
	return mock.OpenFunc(ctx, name)
}

// OpenCalls gets all the calls that were made to Open.
// Check the length with:
//     len(mockedService.OpenCalls())
func (mock *ProjServiceMock) OpenCalls() []struct {
	Ctx  context.Context
	Name string
} {
	var calls []struct {
		Ctx  context.Context
		Name string
	}
	mock.lockOpen.RLock()
	calls = mock.calls.Open
	mock.lockOpen.RUnlock()
	return calls
}

// Projects calls ProjectsFunc.
func (mock *ProjServiceMock) Projects() ([]proj.Project, error) {
	if mock.ProjectsFunc == nil {
		panic("ProjServiceMock.ProjectsFunc: method is nil but Service.Projects was just called")
	}
	callInfo := struct {
	}{}
	mock.lockProjects.Lock()
	mock.calls.Projects = append(mock.calls.Projects, callInfo)
	mock.lockProjects.Unlock()
	return mock.ProjectsFunc()
}

// ProjectsCalls gets all the calls that were made to Projects.
// Check the length with:
//     len(mockedService.ProjectsCalls())
func (mock *ProjServiceMock) ProjectsCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockProjects.RLock()
	calls = mock.calls.Projects
	mock.lockProjects.RUnlock()
	return calls
}
